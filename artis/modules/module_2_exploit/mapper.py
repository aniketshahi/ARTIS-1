"""
ARTIS Vulnerability-to-Exploit Mapper
Maps discovered vulnerabilities to available exploits
"""

from typing import List, Dict, Any, Optional
import uuid
from datetime import datetime

from artis.core.logger import get_logger
from artis.core.config import get_config
from artis.core.message_bus import get_message_bus, RoutingKeys
from artis.core.database import get_database, Vulnerability, Exploit
from artis.modules.module_2_exploit.metasploit_client import MetasploitClient
from artis.modules.module_2_exploit.exploitdb_search import ExploitDBSearch


class VulnerabilityExploitMapper:
    """
    Maps vulnerabilities to available exploits from multiple sources
    """
    
    def __init__(self):
        """Initialize mapper"""
        self.logger = get_logger()
        self.config = get_config()
        self.message_bus = get_message_bus()
        self.db = get_database()
        
        # Initialize exploit sources
        self.msf_client = MetasploitClient()
        self.exploitdb = ExploitDBSearch()
    
    def map_vulnerability(self, vulnerability: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Map a vulnerability to available exploits
        
        Args:
            vulnerability: Vulnerability data
            
        Returns:
            List of matching exploits
        """
        self.logger.info(f"Mapping vulnerability: {vulnerability.get('id')}")
        
        exploits = []
        
        # Try CVE-based search first
        cve_id = vulnerability.get('cve_id')
        if cve_id:
            exploits.extend(self._search_by_cve(cve_id))
        
        # Try service-based search
        service_name = vulnerability.get('service_name')
        service_version = vulnerability.get('service_version')
        if service_name:
            exploits.extend(self._search_by_service(service_name, service_version))
        
        # Remove duplicates
        exploits = self._deduplicate_exploits(exploits)
        
        # Rank exploits
        ranked_exploits = self._rank_exploits(exploits, vulnerability)
        
        self.logger.info(f"Found {len(ranked_exploits)} exploits for vulnerability")
        
        # Store exploits in database
        self._store_exploits(ranked_exploits, vulnerability.get('id'))
        
        # Publish best exploit to message bus
        if ranked_exploits:
            best_exploit = ranked_exploits[0]
            self.message_bus.publish(RoutingKeys.EXPLOIT_READY, {
                'vulnerability_id': vulnerability.get('id'),
                'exploit': best_exploit,
                'target_ip': vulnerability.get('target_ip'),
                'target_port': vulnerability.get('target_port')
            })
        
        return ranked_exploits
    
    def _search_by_cve(self, cve_id: str) -> List[Dict[str, Any]]:
        """
        Search for exploits by CVE
        
        Args:
            cve_id: CVE identifier
            
        Returns:
            List of exploits
        """
        exploits = []
        
        # Search Metasploit
        try:
            msf_exploits = self.msf_client.search_exploits(cve_id)
            for exploit in msf_exploits:
                exploit['source'] = 'metasploit'
                exploit['cve_id'] = cve_id
            exploits.extend(msf_exploits)
        except Exception as e:
            self.logger.error(f"Metasploit search failed: {str(e)}")
        
        # Search Exploit-DB
        try:
            edb_exploits = self.exploitdb.search_by_cve(cve_id)
            for exploit in edb_exploits:
                exploit['source'] = 'exploitdb'
                exploit['cve_id'] = cve_id
            exploits.extend(edb_exploits)
        except Exception as e:
            self.logger.error(f"Exploit-DB search failed: {str(e)}")
        
        return exploits
    
    def _search_by_service(self, service_name: str, service_version: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Search for exploits by service
        
        Args:
            service_name: Service name
            service_version: Service version
            
        Returns:
            List of exploits
        """
        exploits = []
        
        # Build search query
        query = service_name
        if service_version:
            query = f"{service_name} {service_version}"
        
        # Search Metasploit
        try:
            msf_exploits = self.msf_client.search_exploits(query)
            for exploit in msf_exploits:
                exploit['source'] = 'metasploit'
            exploits.extend(msf_exploits)
        except Exception as e:
            self.logger.error(f"Metasploit search failed: {str(e)}")
        
        # Search Exploit-DB
        try:
            edb_exploits = self.exploitdb.search_by_service(service_name, service_version)
            for exploit in edb_exploits:
                exploit['source'] = 'exploitdb'
            exploits.extend(edb_exploits)
        except Exception as e:
            self.logger.error(f"Exploit-DB search failed: {str(e)}")
        
        return exploits
    
    def _deduplicate_exploits(self, exploits: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Remove duplicate exploits
        
        Args:
            exploits: List of exploits
            
        Returns:
            Deduplicated list
        """
        seen = set()
        unique_exploits = []
        
        for exploit in exploits:
            # Create unique key based on name/path
            key = exploit.get('name') or exploit.get('title') or exploit.get('path')
            if key and key not in seen:
                seen.add(key)
                unique_exploits.append(exploit)
        
        return unique_exploits
    
    def _rank_exploits(self, exploits: List[Dict[str, Any]], vulnerability: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Rank exploits by suitability
        
        Args:
            exploits: List of exploits
            vulnerability: Vulnerability data
            
        Returns:
            Ranked list of exploits
        """
        def calculate_score(exploit: Dict[str, Any]) -> float:
            """Calculate exploit suitability score"""
            score = 0.0
            
            # Source preference (Metasploit is more reliable)
            if exploit.get('source') == 'metasploit':
                score += 40
            elif exploit.get('source') == 'exploitdb':
                score += 20
            
            # Rank-based scoring (Metasploit rank)
            rank = exploit.get('rank', '').lower()
            rank_scores = {
                'excellent': 50,
                'great': 40,
                'good': 30,
                'normal': 20,
                'average': 15,
                'low': 10,
            }
            score += rank_scores.get(rank, 10)
            
            # Verified exploits (Exploit-DB)
            if exploit.get('verified'):
                score += 30
            
            # CVE match bonus
            if exploit.get('cve_id') == vulnerability.get('cve_id'):
                score += 50
            
            # CVSS score consideration
            cvss = vulnerability.get('cvss_score', 0)
            score += cvss * 2  # Higher CVSS = higher priority
            
            # Platform match
            vuln_service = vulnerability.get('service_name', '').lower()
            exploit_name = (exploit.get('name') or exploit.get('title', '')).lower()
            if vuln_service in exploit_name:
                score += 20
            
            return score
        
        # Calculate scores and sort
        for exploit in exploits:
            exploit['score'] = calculate_score(exploit)
        
        ranked = sorted(exploits, key=lambda x: x['score'], reverse=True)
        
        # Add rank number
        for i, exploit in enumerate(ranked):
            exploit['rank_position'] = i + 1
        
        return ranked
    
    def _store_exploits(self, exploits: List[Dict[str, Any]], vulnerability_id: str):
        """
        Store exploits in database
        
        Args:
            exploits: List of exploits
            vulnerability_id: Associated vulnerability ID
        """
        try:
            with self.db.get_session() as session:
                for exploit_data in exploits:
                    # Check if exploit already exists
                    exploit_name = exploit_data.get('name') or exploit_data.get('title')
                    existing = session.query(Exploit).filter(
                        Exploit.exploit_name == exploit_name,
                        Exploit.vulnerability_id == vulnerability_id
                    ).first()
                    
                    if existing:
                        continue  # Skip duplicates
                    
                    # Create new exploit record
                    exploit = Exploit(
                        id=str(uuid.uuid4()),
                        vulnerability_id=vulnerability_id,
                        exploit_name=exploit_name,
                        exploit_path=exploit_data.get('name') or exploit_data.get('path'),
                        exploit_type=exploit_data.get('source', 'unknown'),
                        payload_type='auto',  # Will be determined at execution
                        payload_config={},
                        rank=exploit_data.get('rank_position', 999),
                        success_rate=0.0,  # Will be updated based on execution history
                        created_at=datetime.utcnow()
                    )
                    session.add(exploit)
                
                session.commit()
                self.logger.info(f"Stored {len(exploits)} exploits in database")
        
        except Exception as e:
            self.logger.error(f"Failed to store exploits: {str(e)}", exc_info=True)
    
    def start_listening(self):
        """
        Start listening for vulnerability discoveries on message bus
        """
        self.logger.info("Starting vulnerability-to-exploit mapper listener")
        
        def handle_vulnerability(message: Dict[str, Any]):
            """Handle vulnerability discovery message"""
            self.logger.info(f"Received vulnerability: {message.get('id')}")
            self.map_vulnerability(message)
        
        # Subscribe to all vulnerability discoveries
        self.message_bus.subscribe(RoutingKeys.ALL_VULNS, handle_vulnerability)
        
        # Start consuming
        self.message_bus.start_consuming()


# Convenience function
def map_vulnerability(vulnerability: Dict[str, Any]) -> List[Dict[str, Any]]:
    """Map vulnerability to exploits"""
    mapper = VulnerabilityExploitMapper()
    return mapper.map_vulnerability(vulnerability)
