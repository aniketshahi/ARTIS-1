"""
ARTIS Exploit-DB Search
Integration with searchsploit for local exploit database queries
"""

import subprocess
import re
from typing import List, Dict, Any, Optional
from pathlib import Path

from artis.core.logger import get_logger
from artis.core.config import get_config


class ExploitDBSearch:
    """
    Exploit-DB search using searchsploit
    """
    
    def __init__(self):
        """Initialize Exploit-DB search"""
        self.logger = get_logger()
        self.config = get_config()
        
        # Get searchsploit path from config
        self.searchsploit_path = self.config.get('tools.exploitdb.searchsploit', '/usr/bin/searchsploit')
        self.exploitdb_path = self.config.get('tools.exploitdb.path', '/usr/share/exploitdb')
        
        # Verify searchsploit is installed
        if not Path(self.searchsploit_path).exists():
            self.logger.warning(f"searchsploit not found at {self.searchsploit_path}")
    
    def search(self, query: str, platform: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Search Exploit-DB for exploits
        
        Args:
            query: Search query (CVE, keyword, service name, etc.)
            platform: Optional platform filter (linux, windows, web, etc.)
            
        Returns:
            List of matching exploits
        """
        self.logger.info(f"Searching Exploit-DB for: {query}")
        
        try:
            # Build searchsploit command
            command = [self.searchsploit_path, '--json', query]
            
            if platform:
                command.extend(['--platform', platform])
            
            # Execute searchsploit
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode != 0:
                self.logger.error(f"searchsploit failed: {result.stderr}")
                return []
            
            # Parse JSON output
            import json
            try:
                data = json.loads(result.stdout)
                exploits = data.get('RESULTS_EXPLOIT', [])
                
                # Format results
                formatted_exploits = []
                for exploit in exploits:
                    formatted = {
                        'id': exploit.get('EDB-ID'),
                        'title': exploit.get('Title'),
                        'path': exploit.get('Path'),
                        'platform': exploit.get('Platform'),
                        'type': exploit.get('Type'),
                        'date': exploit.get('Date_Published'),
                        'author': exploit.get('Author'),
                        'verified': exploit.get('Verified', False),
                        'codes': exploit.get('Codes', {}),
                        'source': 'exploitdb'
                    }
                    formatted_exploits.append(formatted)
                
                self.logger.info(f"Found {len(formatted_exploits)} exploits in Exploit-DB")
                return formatted_exploits
            
            except json.JSONDecodeError:
                self.logger.error("Failed to parse searchsploit JSON output")
                return self._parse_text_output(result.stdout)
        
        except subprocess.TimeoutExpired:
            self.logger.error("searchsploit timed out")
            return []
        
        except Exception as e:
            self.logger.error(f"Exploit-DB search failed: {str(e)}", exc_info=True)
            return []
    
    def _parse_text_output(self, output: str) -> List[Dict[str, Any]]:
        """
        Parse text output from searchsploit (fallback)
        
        Args:
            output: searchsploit text output
            
        Returns:
            List of exploits
        """
        exploits = []
        
        # Parse line by line
        for line in output.split('\n'):
            # Skip headers and separators
            if not line.strip() or line.startswith('-') or 'Exploit Title' in line:
                continue
            
            # Try to extract exploit info
            # Format: Title | Path
            parts = line.split('|')
            if len(parts) >= 2:
                title = parts[0].strip()
                path = parts[1].strip()
                
                exploit = {
                    'title': title,
                    'path': path,
                    'source': 'exploitdb'
                }
                exploits.append(exploit)
        
        return exploits
    
    def get_exploit_code(self, exploit_id: str) -> Optional[str]:
        """
        Get exploit code by EDB-ID
        
        Args:
            exploit_id: Exploit-DB ID
            
        Returns:
            Exploit code as string
        """
        try:
            command = [self.searchsploit_path, '-x', exploit_id]
            
            result = subprocess.run(
                command,
                capture_output=True,
                text=True,
                timeout=10
            )
            
            if result.returncode == 0:
                return result.stdout
            else:
                self.logger.error(f"Failed to get exploit code: {result.stderr}")
                return None
        
        except Exception as e:
            self.logger.error(f"Failed to get exploit code: {str(e)}")
            return None
    
    def search_by_cve(self, cve_id: str) -> List[Dict[str, Any]]:
        """
        Search for exploits by CVE ID
        
        Args:
            cve_id: CVE identifier (e.g., CVE-2021-1234)
            
        Returns:
            List of matching exploits
        """
        self.logger.info(f"Searching Exploit-DB for CVE: {cve_id}")
        
        # Normalize CVE format
        cve_normalized = cve_id.upper()
        if not cve_normalized.startswith('CVE-'):
            cve_normalized = f"CVE-{cve_normalized}"
        
        return self.search(cve_normalized)
    
    def search_by_service(self, service_name: str, version: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Search for exploits by service name and version
        
        Args:
            service_name: Service name (e.g., 'apache', 'openssh')
            version: Optional version string
            
        Returns:
            List of matching exploits
        """
        query = service_name
        if version:
            query = f"{service_name} {version}"
        
        self.logger.info(f"Searching Exploit-DB for service: {query}")
        return self.search(query)
    
    def rank_exploits(self, exploits: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Rank exploits by reliability and recency
        
        Args:
            exploits: List of exploits
            
        Returns:
            Sorted list of exploits
        """
        def exploit_score(exploit: Dict[str, Any]) -> float:
            """Calculate exploit score"""
            score = 0.0
            
            # Verified exploits get higher score
            if exploit.get('verified'):
                score += 50
            
            # Recent exploits get higher score
            date_str = exploit.get('date', '')
            if date_str:
                try:
                    from datetime import datetime
                    date = datetime.strptime(date_str, '%Y-%m-%d')
                    years_old = (datetime.now() - date).days / 365
                    score += max(0, 20 - years_old * 2)  # Newer is better
                except:
                    pass
            
            # Platform-specific scoring
            platform = exploit.get('platform', '').lower()
            if platform in ['windows', 'linux']:
                score += 10
            
            # Type-specific scoring
            exploit_type = exploit.get('type', '').lower()
            if 'remote' in exploit_type:
                score += 15
            elif 'local' in exploit_type:
                score += 5
            
            return score
        
        # Sort by score (descending)
        ranked = sorted(exploits, key=exploit_score, reverse=True)
        
        # Add rank to each exploit
        for i, exploit in enumerate(ranked):
            exploit['rank'] = i + 1
            exploit['score'] = exploit_score(exploit)
        
        return ranked


# Convenience functions
def search_exploits(query: str, platform: Optional[str] = None) -> List[Dict[str, Any]]:
    """Search Exploit-DB"""
    searcher = ExploitDBSearch()
    return searcher.search(query, platform)


def search_by_cve(cve_id: str) -> List[Dict[str, Any]]:
    """Search by CVE ID"""
    searcher = ExploitDBSearch()
    return searcher.search_by_cve(cve_id)
